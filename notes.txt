Representation of MemoryOps
------------------------------

MemoryOps can contain both "set" operations (i.e. *ptr = value) and "delta"
(i.e. *ptr += value) operations. The order of operations is preserved, but
this is very inconvenient and inefficient to manipulate. So MemoryOps should
implement several algorithms to handle them efficiently.

There are several cases to deal with.

- Delta operations can be combined, even across other non-relevalent ops.
	e.g. MemoryOps[0+=4, 1=12, 0+=5]
- Set operation can make previous delta or set operations effectively no-op.
	e.g. MemoryOps[0+=3, 0=42], MemoryOps[0=9, 0=42]
- Some operations have references to previous operations to be overwritten.
	e.g. MemoryOps[0=17, 1=mptr[0], 0=42]
- Some operations can be too verbose to be propagated automatically.
	e.g. MemoryOps[0+=mptr[0]+mptr[1], 1+=mptr[1]+mptr[2],
	               2+=mptr[2]+mptr[3], 3+=mptr[3]+mptr[4], 0=0, 1=0]
- Two or more consecutive MemoryOps can be combined.
	e.g. MemoryOps[0+=4; -1] then MemoryOps[1+=4-mptr[0]; 1]
- Some MemoryOps can affect optimization of next nodes.
	e.g. MemoryOps[0=0, -1+=1] then LoopWhile[...]
- Multiple execution of MemoryOps' can be merged into one.
	e.g. LoopWhile[MemoryOps[0=-1, 1=8]]
- But sometimes merging is more compliated, or even infeasible.
	e.g. LoopWhile[MemoryOps[1+=1; 4]]




vim: tw=78

