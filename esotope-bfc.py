#!/usr/bin/env python
# Esotope Brainfuck-to-C Compiler
# Copyright (c) 2009, Kang Seonghoon.

import sys
from cStringIO import StringIO


class Expr(object):
    def __add__(self, rhs): return Add(self, rhs)
    def __radd__(self, lhs): return Add(lhs, self)
    def __sub__(self, rhs): return Subtract(self, rhs)
    def __rsub__(self, lhs): return Subtract(lhs, self)
    def __mul__(self, rhs): return Multiply(self, rhs)
    def __rmul__(self, lhs): return Multiply(lhs, self)

    def __str__(self): raise NotImplemented('should be overriden')
    def __repr__(self): raise NotImplemented('should be overriden')

class MemoryRef(Expr):
    def __init__(self, offset): self.offset = offset
    def __str__(self): return 'mptr[%s]' % self.offset
    def __repr__(self): return 'mptr[%r]' % self.offset

class Add(Expr):
    def __init__(self, lhs, rhs): self.lhs = lhs; self.rhs = rhs
    def __str__(self): return '(%s + %s)' % (self.lhs, self.rhs)
    def __repr__(self): return '(%r + %r)' % (self.lhs, self.rhs)

class Subtract(Expr):
    def __init__(self, lhs, rhs): self.lhs = lhs; self.rhs = rhs
    def __str__(self): return '(%s - %s)' % (self.lhs, self.rhs)
    def __repr__(self): return '(%r - %r)' % (self.lhs, self.rhs)

class Multiply(Expr):
    def __init__(self, lhs, rhs): self.lhs = lhs; self.rhs = rhs
    def __str__(self): return '(%s * %s)' % (self.lhs, self.rhs)
    def __repr__(self): return '(%r * %r)' % (self.lhs, self.rhs)


def insert_indent(s):
    if s == '': return s
    return '\t' + s.rstrip('\n').replace('\n', '\n\t') + '\n'

class Node(object):
    def __str__(self): raise NotImplemented('should be overriden')
    def __repr__(self): raise NotImplemented('should be overriden')

class ComplexNode(Node, list):
    def _indentall(self):
        return ''.join(map(insert_indent, map(str, self)))

    def _repr(self, name):
        return name + list.__repr__(self)

class Program(ComplexNode):
    def __str__(self):
        return ('/* generated by esotope-bfc */\n'
                '#include <stdio.h>\n'
                'char mem[30000], *mptr = mem;\n'
                'int main(void) {\n'
                '%s'
                '\treturn 0;\n'
                '}\n') % self._indentall()

    def __repr__(self):
        return self._repr('Program')

class SetCurrent(Node):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return '*mptr = %s;\n' % self.value

    def __repr__(self):
        return 'SetCurrent[%r]' % self.value

class AdjustMemory(Node):
    def __init__(self, offset=0, changes=None):
        self.offset = offset
        if changes:
            self.changes = dict(changes)
            for k, v in self.changes.items():
                if v == 0: del self.changes[k]
        else:
            self.changes = {}

    def __getitem__(self, offset):
        assert isinstance(offset, (int, long))
        return self.changes.get(offset, 0)

    def __setitem__(self, offset, delta):
        assert isinstance(offset, (int, long))
        if delta == 0:
            try: del self.changes[offset]
            except KeyError: pass
        else:
            self.changes[offset] = delta

    def __str__(self):
        codes = []

        for k, v in self.changes.items():
            if v < 0:
                codes.append('mptr[%d] -= %s;\n' % (k, -v))
            elif v != 0:
                codes.append('mptr[%d] += %s;\n' % (k, v))

        if self.offset < 0:
            codes.append('mptr -= %s;\n' % -self.offset)
        elif self.offset != 0:
            codes.append('mptr += %s;\n' % self.offset)

        return ''.join(codes)

    def __repr__(self):
        items = sorted(self.changes.items())
        return 'AdjustMemory[offset=%r, %s]' % (
                self.offset, ', '.join('%d:%r' % (k,v) for k, v in items))

class Input(Node):
    def __str__(self):
        return '*mptr = getchar();\n'

    def __repr__(self):
        return 'Input[]'

class Output(Node):
    def __str__(self):
        return 'putchar(*mptr);\n'

    def __repr__(self):
        return 'Output[]'

class LoopWhile(ComplexNode):
    def __str__(self):
        return ('while (*mptr) {\n'
                '%s'
                '}\n') % self._indentall()

    def __repr__(self):
        return self._repr('LoopWhile')


class Compiler(object):
    def parse(self, fp):
        nodestack = [Program()]

        memchanges = {}
        ptroffset = 0
        for lineno, line in enumerate(fp):
            for ch in line:
                if ch == '+':
                    memchanges[ptroffset] = memchanges.get(ptroffset, 0) + 1
                elif ch == '-':
                    memchanges[ptroffset] = memchanges.get(ptroffset, 0) - 1
                elif ch == '>':
                    ptroffset += 1
                elif ch == '<':
                    ptroffset -= 1
                elif ch in '.,[]':
                    if ptroffset != 0 or any(memchanges.values()):
                        nodestack[-1].append(AdjustMemory(ptroffset, memchanges))
                    memchanges = {}
                    ptroffset = 0

                    if ch == '.':
                        nodestack[-1].append(Output())
                    elif ch == ',':
                        nodestack[-1].append(Input())
                    elif ch == '[':
                        nodestack.append(LoopWhile())
                    else:
                        if len(nodestack) < 2:
                            raise ValueError('Not matching ] at line %d' % (lineno+1))
                        loop = nodestack.pop()
                        nodestack[-1].append(loop)

        if ptroffset != 0 or any(memchanges.values()):
            nodestack[-1].append(AdjustMemory(ptroffset, memchanges))
        if len(nodestack) != 1:
            raise ValueError('Premature end of the loop')

        return nodestack[0]

    # tries to optimize tight loop: LoopWhile[AdjustMemory[offset=0, 0:+-1, ...]].
    def optimize_tightloop(self, node):
        if not isinstance(node, ComplexNode):
            return node

        overflow = 256 # XXX hard-coded, must be the power of 2

        inodes = []
        for inode in node[:]:
            if isinstance(inode, LoopWhile) and len(inode) == 1 and \
                    isinstance(inode[0], AdjustMemory) and inode[0].offset == 0:
                adjustnode = inode[0]
                if adjustnode[0] == 1:
                    mult = overflow - MemoryRef(0)
                elif adjustnode[0] == -1:
                    mult = MemoryRef(0)
                else:
                    mult = None

                if mult is not None:
                    adjustnode[0] = 0
                    for k in adjustnode.changes.keys():
                        adjustnode[k] *= mult
                    inodes.append(SetCurrent(0))
                    inodes.append(adjustnode)
                    continue

            if isinstance(inode, ComplexNode):
                inodes.append(self.optimize_tightloop(inode))
            else:
                inodes.append(inode)

        node[:] = inodes
        return node

def main(argv):
    if len(argv) < 2:
        print >>sys.stderr, 'Usage: %s filename' % argv[0]
        return 1

    compiler = Compiler()
    node = compiler.parse(file(argv[1], 'r'))
    node = compiler.optimize_tightloop(node)
    print node
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv))

